# Clip 1. 돌아보기 - map 함수가 하는 일

처음에는 명령적인 방식을 사용해서 문제를 해결함 > 이 때는 부수효과가 발생하는 for문을 사용함

for문을 제거하기 위해서 고차함수를 사용하여 선언적인 방법으로 문제를 해결함

## 공통적인 부수효과 추출하기

`map(f): Array<A> => Array<B>`

효과와 계산을 분리
배열의 원소가 몇 개라도 함수의 실행이 가능

## Array map의 타입

제네릭으로 구현한 map

`type map<A, B> = (Array<A>, A => B) => Array<B>`

## 부수효과를 분리해서 모으기

for문... 틀에 박힌 부수효과

```typescript
import { cart } from './cart';

function list() {
  let html = '<ul>';
  for (let i = 0; i < cart.length; i++) {
    html += `<li>${cart[i]}</li>`;
  }
  html += '</ul>';
  return html;
}
```

부수효과를 추상화한 map의 사용

1. 여러 곳에 흩어진 판에 박힌 코드를 한 곳으로 모음
2. map, filter, reduce를 사용해서 리팩토링
3. 비슷한 일을 하는 코드는 모듈화, 재사용성이 높아짐

## map을 잘못 사용하는 경우(부수효과)

map의 콜백 함수가 리턴 함수가 없을 경우 > 부수효과가 발생하는 함수

## 중첩된 부수효과

중첩된 부수효과를 처리하는 flatMap

`flat: Array<Array<T>> => Array<T>`

# Clip 2. 미리보기 - 함수형 방식으로 null 처리하기

## total function 전 함수 vs partial function 부분 함수

### (total) function (전) 함수\*\*

정의역의 모든 원소에 대해 함수가 정의되어야 한다.

### partial function 부분 함수\*\*

가능한 입력 중에 **일부**에만 반환값이 정의되어 있다.

## number의 부재를 나타내는 타입

`Option<number> = some<number> | none`

## Array map의 타입과 비교하기

Array의 map

```typescript
(arr: Array<A>, f: (a: A) => B): Array<B>
```

Option의 map

```typescript
(oa: Option<A>, f: (a: A) => B): Option<B>
```

## Option의 map 미리보기

### 주어진 데이터

```typescript
export const cart: Array<Item> = [
  {
    code: 'tomato',
    outOfStock: false,
    name: '토마토',
    price: 7000,
    quantity: 2,
    discountPrice: 1000,
  },
  {
    code: 'orange',
    outOfStock: true,
    name: '오렌지',
    price: 15000,
    quantity: 3,
    discountPrice: 2000,
  },
  {
    code: 'apple',
    outOfStock: false,
    name: '사과',
    price: 10000,
    quantity: 1,
  },
];
```

### 원하는 결과

장바구니

- 토마토
  - 가격: 6000원 (1000원 할인)
  - 수량: 2상자
- 오렌지(품절)
  - ~~가격: 15000원 (2000원 할인)~~
  - ~~수량: 3상자~~
- 사과
  - 가격: 10000원
  - 수량: 1상자

전체 수량: 3상자
전체 가격: 22000원 (총 2000원 할인)

# Clip 3. 부분 함수

## Option 없을 수도, 실패할 수도 있는 값

### 입력에 대응되는 출력이 없을 때

주어진 인자에 대응되는 반환 값이 없으면 어떻게 해왔나?

타입에 포함된 임의의 값을 대신 반환하기

예) -1, 0, null, undefined, Infinity, NaN...

### 입력에 대응되는 값을 찾지 못했을 때

```typescript
const arr = ['apple', 'banana', 'strawberry'];

arr.indesOf('banana'); // 배열에서 위치 인덱스 찾기. 결과는 1

arr.indexOf('Onion'); // 배열에 찾는 값이 없을 때? 결과는 -1
```

### 입력에 대응되는 계산이 불가능할 때

```typescript
const div = (a, b) => a / b;

div(10, 5); // 나눌 수 있는 경우

div(10, 0); // 0으로 나눌 수 있나? 결과는 Infinity

div(0, 0); // 0을 0으로? 결과는 NaN
```

### Option VS Try

|       **Option**        |           **Try**           |
| :---------------------: | :-------------------------: |
| 반환값이 있는지 없는지? | 실패했다면 이유가 무엇인지? |
|    some(T) 값이 있다    |  success(T) 반환 값이 있다  |
|    none() 값이 없다     |  fail(E) 실패한 이유, 에러  |

# Clip 4. if문 살펴보기

```typescript
export interface Item {
  readonly code: string;
  readonly outOfStock: boolean;
  readonly name: string;
  readonly price: number;
  readonly quantity: number;
  readonly discountPrice?: number;
}

export const cart: Array<Item> = [
  {
    code: 'tomato',
    outOfStock: false,
    name: '토마토',
    price: 7000,
    quantity: 2,
    discountPrice: 1000,
  },
  {
    code: 'orange',
    outOfStock: true,
    name: '오렌지',
    price: 15000,
    quantity: 3,
    discountPrice: 2000,
  },
  {
    code: 'apple',
    outOfStock: false,
    name: '사과',
    price: 10000,
    quantity: 1,
  },
];

const stockItem = (item: Item): string => {
  let saleText = '';
  let discountPrice = 0;
  if (item.discountPrice !== undefined) {
    saleText = `(${item.discountPrice}원 할인)`;
    discountPrice = item.discountPrice;
  }
  return `
    <div class="item">
      <div class="item-name">${item.name}</div>
      <div class="item-price">${
        item.price - discountPrice
      } 원 ${stockItem}</div>
      <div class="item-quantity">${item.quantity}상자</div>
    </div>
  `;
};

const outOfStockItem = (item: Item): string => `
  <div class="item gray">
    <div class="item-name strike">${item.name}</div>
    <div class="item-price strike">${item.price}원</div>
    <div class="item-quantity strike">${item.quantity}상자</div>
  </div>
`;

const getItem = (item: Item): string => {
  if (item.quantity > 0) {
    return stockItem(item);
  } else {
    return outOfStockItem(item);
  }
};

const totalCalculator = (
  items: Array<Item>,
  getValue: (item: Item) => number
): number => {
  const result: Array<number> = [];
  items.forEach(function (item) {
    // map은 잘못된 사용. forEach는 부수효과를 일으키므로 순수하지 않다.
    // 그리고 void를 반환하므로 더이상 함수를 합성할 수 없다.
    if (item.outOfStock === false) {
      result.push(getValue(item));
    }
  });
  return result.reduce((total, value) => total + value, 0);
};

const getTotalCount = (items: Array<Item>): string => {
  // 전체 목록 중 재고가 있는 상품만 getValue를 실행하고 그 결과를 모두 더한다.

  // 1. 재고가 있는 상품만 분류하기
  // 2. 분류된 상품들에 대해서 getValue 실행하기
  // 3. getValue가 실행된 값 모두 더하기
  return item
    .filter((item) => !item.outOfStock)
    .map(getValue)
    .reduce((total, value) => total + value, 0);
};

const getTotalPrice = (items: Array<Item>): string => {
  const totalPrice = totalCalculator(
    items,
    (item) => item.price * item.quantity
  );

  const totalDiscountPrice = totalCalculator(items, (item) => {
    let discountPrice = 0;
    if (item.discountPrice !== undefined) {
      discountPrice = item.discountPrice;
    }
    return discountPrice * item.quantity;
  });

  return `<h2>전체 가격: ${
    totalPrice - totalDiscountPrice
  }원 (총 ${totalDiscountPrice}원 할인)</h2>`;
};

const list = (items: Array<Item>) => {
  // 1. 목록에 있는 아이템을 태그로 변경
  // 2. 태그의 목록을 모두 하나의 문자열로 연결
  return `
    <ul>
      ${items.map(getItem).reduce((tags, tag) => tags + tag, '')}
    </ul>
  `;
};

const app = document.getElementById('app');
if (app != null) {
  app.innerHTML = `
    <h1>Cart</h1>
    ${list(cart)}
    ${getTotalCount(cart)}
    ${getTotalPrice(cart)}
  `;
}
```
