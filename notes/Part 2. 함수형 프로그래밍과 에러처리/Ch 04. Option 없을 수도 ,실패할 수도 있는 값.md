# Clip 1. 돌아보기 - map 함수가 하는 일

처음에는 명령적인 방식을 사용해서 문제를 해결함 > 이 때는 부수효과가 발생하는 for문을 사용함

for문을 제거하기 위해서 고차함수를 사용하여 선언적인 방법으로 문제를 해결함

## 공통적인 부수효과 추출하기

`map(f): Array<A> => Array<B>`

효과와 계산을 분리
배열의 원소가 몇 개라도 함수의 실행이 가능

## Array map의 타입

제네릭으로 구현한 map

`type map<A, B> = (Array<A>, A => B) => Array<B>`

## 부수효과를 분리해서 모으기

for문... 틀에 박힌 부수효과

```typescript
import { cart } from './cart';

function list() {
  let html = '<ul>';
  for (let i = 0; i < cart.length; i++) {
    html += `<li>${cart[i]}</li>`;
  }
  html += '</ul>';
  return html;
}
```

부수효과를 추상화한 map의 사용

1. 여러 곳에 흩어진 판에 박힌 코드를 한 곳으로 모음
2. map, filter, reduce를 사용해서 리팩토링
3. 비슷한 일을 하는 코드는 모듈화, 재사용성이 높아짐

## map을 잘못 사용하는 경우(부수효과)

map의 콜백 함수가 리턴 함수가 없을 경우 > 부수효과가 발생하는 함수

## 중첩된 부수효과

중첩된 부수효과를 처리하는 flatMap

`flat: Array<Array<T>> => Array<T>`

# Clip 2. 미리보기 - 함수형 방식으로 null 처리하기

## total function 전 함수 vs partial function 부분 함수

### (total) function (전) 함수\*\*

정의역의 모든 원소에 대해 함수가 정의되어야 한다.

### partial function 부분 함수\*\*

가능한 입력 중에 **일부**에만 반환값이 정의되어 있다.

## number의 부재를 나타내는 타입

`Option<number> = some<number> | none`

## Array map의 타입과 비교하기

Array의 map

```typescript
(arr: Array<A>, f: (a: A) => B): Array<B>
```

Option의 map

```typescript
(oa: Option<A>, f: (a: A) => B): Option<B>
```

## Option의 map 미리보기

### 주어진 데이터

```typescript
export const cart: Array<Item> = [
  {
    code: 'tomato',
    outOfStock: false,
    name: '토마토',
    price: 7000,
    quantity: 2,
    discountPrice: 1000,
  },
  {
    code: 'orange',
    outOfStock: true,
    name: '오렌지',
    price: 15000,
    quantity: 3,
    discountPrice: 2000,
  },
  {
    code: 'apple',
    outOfStock: false,
    name: '사과',
    price: 10000,
    quantity: 1,
  },
];
```

### 원하는 결과

장바구니

- 토마토
  - 가격: 6000원 (1000원 할인)
  - 수량: 2상자
- 오렌지(품절)
  - ~~가격: 15000원 (2000원 할인)~~
  - ~~수량: 3상자~~
- 사과
  - 가격: 10000원
  - 수량: 1상자

전체 수량: 3상자
전체 가격: 22000원 (총 2000원 할인)

# Clip 3. 부분 함수

## Option 없을 수도, 실패할 수도 있는 값

### 입력에 대응되는 출력이 없을 때

주어진 인자에 대응되는 반환 값이 없으면 어떻게 해왔나?

타입에 포함된 임의의 값을 대신 반환하기

예) -1, 0, null, undefined, Infinity, NaN...

### 입력에 대응되는 값을 찾지 못했을 때

```typescript
const arr = ['apple', 'banana', 'strawberry'];

arr.indesOf('banana'); // 배열에서 위치 인덱스 찾기. 결과는 1

arr.indexOf('Onion'); // 배열에 찾는 값이 없을 때? 결과는 -1
```

### 입력에 대응되는 계산이 불가능할 때

```typescript
const div = (a, b) => a / b;

div(10, 5); // 나눌 수 있는 경우

div(10, 0); // 0으로 나눌 수 있나? 결과는 Infinity

div(0, 0); // 0을 0으로? 결과는 NaN
```

### Option VS Try

|       **Option**        |           **Try**           |
| :---------------------: | :-------------------------: |
| 반환값이 있는지 없는지? | 실패했다면 이유가 무엇인지? |
|    some(T) 값이 있다    |  success(T) 반환 값이 있다  |
|    none() 값이 없다     |  fail(E) 실패한 이유, 에러  |
