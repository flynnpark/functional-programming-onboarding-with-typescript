# Clip 1. 돌아보기 - map 함수가 하는 일

처음에는 명령적인 방식을 사용해서 문제를 해결함 > 이 때는 부수효과가 발생하는 for문을 사용함

for문을 제거하기 위해서 고차함수를 사용하여 선언적인 방법으로 문제를 해결함

## 공통적인 부수효과 추출하기

`map(f): Array<A> => Array<B>`

효과와 계산을 분리
배열의 원소가 몇 개라도 함수의 실행이 가능

## Array map의 타입

제네릭으로 구현한 map

`type map<A, B> = (Array<A>, A => B) => Array<B>`

## 부수효과를 분리해서 모으기

for문... 틀에 박힌 부수효과

```typescript
import { cart } from './cart';

function list() {
  let html = '<ul>';
  for (let i = 0; i < cart.length; i++) {
    html += `<li>${cart[i]}</li>`;
  }
  html += '</ul>';
  return html;
}
```

부수효과를 추상화한 map의 사용

1. 여러 곳에 흩어진 판에 박힌 코드를 한 곳으로 모음
2. map, filter, reduce를 사용해서 리팩토링
3. 비슷한 일을 하는 코드는 모듈화, 재사용성이 높아짐

## map을 잘못 사용하는 경우(부수효과)

map의 콜백 함수가 리턴 함수가 없을 경우 > 부수효과가 발생하는 함수

## 중첩된 부수효과

중첩된 부수효과를 처리하는 flatMap

`flat: Array<Array<T>> => Array<T>`

# Clip 2. 미리보기 - 함수형 방식으로 null 처리하기

## total function 전 함수 vs partial function 부분 함수

### (total) function (전) 함수\*\*

정의역의 모든 원소에 대해 함수가 정의되어야 한다.

### partial function 부분 함수\*\*

가능한 입력 중에 **일부**에만 반환값이 정의되어 있다.

## number의 부재를 나타내는 타입

`Option<number> = some<number> | none`

## Array map의 타입과 비교하기

Array의 map

```typescript
(arr: Array<A>, f: (a: A) => B): Array<B>
```

Option의 map

```typescript
(oa: Option<A>, f: (a: A) => B): Option<B>
```

## Option의 map 미리보기

### 주어진 데이터

```typescript
export const cart: Array<Item> = [
  {
    code: 'tomato',
    outOfStock: false,
    name: '토마토',
    price: 7000,
    quantity: 2,
    discountPrice: 1000,
  },
  {
    code: 'orange',
    outOfStock: true,
    name: '오렌지',
    price: 15000,
    quantity: 3,
    discountPrice: 2000,
  },
  {
    code: 'apple',
    outOfStock: false,
    name: '사과',
    price: 10000,
    quantity: 1,
  },
];
```

### 원하는 결과

장바구니

- 토마토
  - 가격: 6000원 (1000원 할인)
  - 수량: 2상자
- 오렌지(품절)
  - ~~가격: 15000원 (2000원 할인)~~
  - ~~수량: 3상자~~
- 사과
  - 가격: 10000원
  - 수량: 1상자

전체 수량: 3상자
전체 가격: 22000원 (총 2000원 할인)
