# Clip 1. 돌아보기 > 함수와 함수 합성

## 명령형에서 함수형 추상화로

명령형 틀에 박힌 코드

```javascript
function sum1To100() {
  let sum = 0;
  for (let i = 1; i <= 100; i++) {
    sum += i;
  }
  return sum;
}
```

함수형 추상화

```
range(1, 100)

입력(매개변수)

loop
const plus = (a, b) => a + b

출력(반환)

5050
loop(plus, 0, range(1, 100))
```

# Clip 2. 미리보기 > 부수효과와 map 함수(문제 > 상품목록 화면에 보여주기)

## Array의 map 미리보기

for 문... 틀에 박힌 부수효과

```javascript
import { cart } from './cart';

function list() {
  let html = '<ul>';
  for (let i = 0; i < cart.length; i++) {
    const item = cart[i];
    html += `<li>${item.name}</li>`;
  }
  html += '</ul>';
  return html;
}
```

부수효과를 추상화한 map의 사용

```
cart: Array<Item>

cart.map(item)
  item => string(html)

Array<string>(html의 Array)
```

# Clip 3. Array 다시보기 > 비결정성

## 여러 개의 값을 담을 수 있는 배열

1개로 결정되는 값

```typescript
const one: number = 1;
const str: string = 'hello world';
```

개수를 결정할 수 없는 값들

```typescript
const numbers: Array<number> = [1, 2, 3];
const strings: Array<string> = ['hello', 'world'];
```

## Array와 List

- Array 배열
  인덱스로 임의 접근이 편하다

- List 리스트
  순차적, 재귀적 구조

## 비결정적인 함수

```typescript
type filter = <A>(as: Array<A>, pred: (a: A) => boolean) => Array<A>;
```

- 입출력 값의 개수와 상관 없이 항상 같은 동작을 해야 한다.
- 몇 개의 값이 입력될 지 모르고, 몇 개의 값이 출력될 지 알 수 없다.

# Clip 4. for문으로 해결하기

cart.ts

```typescript
export interface Item {
  code: string;
  outOfStock: boolean;
  name: string;
  price: number;
  quantity: number;
}

export const cart: Array<Item> = [
  {
    code: 'tomato',
    outOfStock: false,
    name: '토마토',
    price: 7000,
    quantity: 2,
  },
  {
    code: 'orange',
    outOfStock: true,
    name: '오렌지',
    price: 15000,
    quantity: 3,
  },
  {
    code: 'apple',
    outOfStock: false,
    name: '사과',
    price: 10000,
    quantity: 1,
  },
];
```

clip3.ts

```typescript
import './index.css';
import { cart } from './cart';

const list = () => {
  let html = '<ul>';
  let totalCount = 0;
  let totalPrice = 0;

  for (let i = 0; i < cart.length; i++) {
    const item = cart[i];
    html += `
      <div class="item">
        <div class="item-name">${item.name}</div>
        <div class="item-price">${item.price}원</div>
        <div class="item-quantity">${item.quantity}상자</div>
      </div>
    `;
    totalCount += item.quantity;
    totalPrice += item.price * item.quantity;
  }
  html += '</ul>';

  return `
      ${html}
      <h2>전체 수량: ${totalCount}</h2>
      <h2>전체 가격: ${totalPrice}원</h2>
  `;
};

const app = document.getElementById('app');
if (app != null) {
  app.innerHTML = `
    <h1>Cart</h1>
    ${list()}
  `;
}
```

관심사가 한 가지고 집중되지 못하고 분산되어 있다.

clip3.ts

```typescript
import './index.css';
import { cart } from './cart';

const list = () => {
  let html = '<ul>';

  for (let i = 0; i < cart.length; i++) {
    const item = cart[i];
    if (!item.outOfStock) {
      html += `
        <div class="item">
          <div class="item-name">${item.name}</div>
          <div class="item-price">${item.price}원</div>
          <div class="item-quantity">${item.quantity}상자</div>
        </div>
      `;
    } else {
      html += `
        <div class="item gray">
          <div class="item-name strike">${item.name}</div>
          <div class="item-price strike">${item.price}원</div>
          <div class="item-quantity strike">${item.quantity}상자</div>
        </div>
      `;
    }
  }
  html += '</ul>';

  let totalCount = 0;
  for (let i = 0; i < cart.length; i++) {
    const item = cart[i];
    if (!item.outOfStock) {
      totalCount += item.quantity;
    }
  }
  html += `<h2>전체 수량: ${totalCount}</h2>`;

  let totalPrice = 0;
  for (let i = 0; i < cart.length; i++) {
    const item = cart[i];
    if (!item.outOfStock) {
      totalPrice += item.price * item.quantity;
    }
  }
  html += `<h2>전체 가격: ${totalPrice}원</h2>`;

  return `
      ${html}
  `;
};

const app = document.getElementById('app');
if (app != null) {
  app.innerHTML = `
    <h1>Cart</h1>
    ${list()}
  `;
}
```

관심사는 분리되었지만, 같은 코드가 반복되어 있다.

# Clip 5. 고차함수

## 고차함수란 무엇인가

- 하나 이상의 함수를 인수로 취한다.
- 함수를 결과로 반환한다.

다른 함수를 매개변수로 입력 받는 함수

```typescript
type hof1 = (func: 함수, x: 인자) => B;

function 고차함수1(func: 함수, x: 인자) {
  // ...
  return func(x);
}
```

```typescript
type hof2 = (a: A) => 함수;

function 고차함수2(a: A) {
  // ...
  return (x: 인자) => {
    // ...
  };
}
```

## 고차함수 조합의 예

```typescript
객체.메서드(함수);

array.map(item);

array.filter(isInStock);

array.reduce(plus, 0);
```

map.ts

```typescript
export const map = <A, B>(array: Array<A>, f: (a: A) => B): Array<B> => {
  const result: Array<B> = [];
  for (const value of array) {
    result.push(f(value));
  }
  return result;
};
```
