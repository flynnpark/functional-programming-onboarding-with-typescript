# Clip 1. 돌아보기 > 함수와 함수 합성

## 명령형에서 함수형 추상화로

명령형 틀에 박힌 코드

```javascript
function sum1To100() {
  let sum = 0;
  for (let i = 1; i <= 100; i++) {
    sum += i;
  }
  return sum;
}
```

함수형 추상화

```
range(1, 100)

입력(매개변수)

loop
const plus = (a, b) => a + b

출력(반환)

5050
loop(plus, 0, range(1, 100))
```

# Clip 2. 미리보기 > 부수효과와 map 함수(문제 > 상품목록 화면에 보여주기)

## Array의 map 미리보기

for 문... 틀에 박힌 부수효과

```javascript
import { cart } from './cart';

function list() {
  let html = '<ul>';
  for (let i = 0; i < cart.length; i++) {
    const item = cart[i];
    html += `<li>${item.name}</li>`;
  }
  html += '</ul>';
  return html;
}
```

부수효과를 추상화한 map의 사용

```
cart: Array<Item>

cart.map(item)
  item => string(html)

Array<string>(html의 Array)
```

# Clip 3. Array 다시보기 > 비결정성

## 여러 개의 값을 담을 수 있는 배열

1개로 결정되는 값

```typescript
const one: number = 1;
const str: string = 'hello world';
```

개수를 결정할 수 없는 값들

```typescript
const numbers: Array<number> = [1, 2, 3];
const strings: Array<string> = ['hello', 'world'];
```

## Array와 List

- Array 배열
  인덱스로 임의 접근이 편하다

- List 리스트
  순차적, 재귀적 구조

## 비결정적인 함수

```typescript
type filter = <A>(as: Array<A>, pred: (a: A) => boolean) => Array<A>;
```

- 입출력 값의 개수와 상관 없이 항상 같은 동작을 해야 한다.
- 몇 개의 값이 입력될 지 모르고, 몇 개의 값이 출력될 지 알 수 없다.

# Clip 4. for문으로 해결하기

cart.ts

```typescript
export interface Item {
  code: string;
  outOfStock: boolean;
  name: string;
  price: number;
  quantity: number;
}

export const cart: Array<Item> = [
  {
    code: 'tomato',
    outOfStock: false,
    name: '토마토',
    price: 7000,
    quantity: 2,
  },
  {
    code: 'orange',
    outOfStock: true,
    name: '오렌지',
    price: 15000,
    quantity: 3,
  },
  {
    code: 'apple',
    outOfStock: false,
    name: '사과',
    price: 10000,
    quantity: 1,
  },
];
```

clip3.ts

```typescript
import './index.css';
import { cart } from './cart';

const list = () => {
  let html = '<ul>';
  let totalCount = 0;
  let totalPrice = 0;

  for (let i = 0; i < cart.length; i++) {
    const item = cart[i];
    html += `
      <div class="item">
        <div class="item-name">${item.name}</div>
        <div class="item-price">${item.price}원</div>
        <div class="item-quantity">${item.quantity}상자</div>
      </div>
    `;
    totalCount += item.quantity;
    totalPrice += item.price * item.quantity;
  }
  html += '</ul>';

  return `
      ${html}
      <h2>전체 수량: ${totalCount}</h2>
      <h2>전체 가격: ${totalPrice}원</h2>
  `;
};

const app = document.getElementById('app');
if (app != null) {
  app.innerHTML = `
    <h1>Cart</h1>
    ${list()}
  `;
}
```

관심사가 한 가지고 집중되지 못하고 분산되어 있다.

clip3.ts

```typescript
import './index.css';
import { cart } from './cart';

const list = () => {
  let html = '<ul>';

  for (let i = 0; i < cart.length; i++) {
    const item = cart[i];
    if (!item.outOfStock) {
      html += `
        <div class="item">
          <div class="item-name">${item.name}</div>
          <div class="item-price">${item.price}원</div>
          <div class="item-quantity">${item.quantity}상자</div>
        </div>
      `;
    } else {
      html += `
        <div class="item gray">
          <div class="item-name strike">${item.name}</div>
          <div class="item-price strike">${item.price}원</div>
          <div class="item-quantity strike">${item.quantity}상자</div>
        </div>
      `;
    }
  }
  html += '</ul>';

  let totalCount = 0;
  for (let i = 0; i < cart.length; i++) {
    const item = cart[i];
    if (!item.outOfStock) {
      totalCount += item.quantity;
    }
  }
  html += `<h2>전체 수량: ${totalCount}</h2>`;

  let totalPrice = 0;
  for (let i = 0; i < cart.length; i++) {
    const item = cart[i];
    if (!item.outOfStock) {
      totalPrice += item.price * item.quantity;
    }
  }
  html += `<h2>전체 가격: ${totalPrice}원</h2>`;

  return `
      ${html}
  `;
};

const app = document.getElementById('app');
if (app != null) {
  app.innerHTML = `
    <h1>Cart</h1>
    ${list()}
  `;
}
```

관심사는 분리되었지만, 같은 코드가 반복되어 있다.

# Clip 5. 고차함수

## 고차함수란 무엇인가

- 하나 이상의 함수를 인수로 취한다.
- 함수를 결과로 반환한다.

다른 함수를 매개변수로 입력 받는 함수

```typescript
type hof1 = (func: 함수, x: 인자) => B;

function 고차함수1(func: 함수, x: 인자) {
  // ...
  return func(x);
}
```

```typescript
type hof2 = (a: A) => 함수;

function 고차함수2(a: A) {
  // ...
  return (x: 인자) => {
    // ...
  };
}
```

## 고차함수 조합의 예

```typescript
객체.메서드(함수);

array.map(item);

array.filter(isInStock);

array.reduce(plus, 0);
```

map.ts

```typescript
export const map = <A, B>(array: Array<A>, f: (a: A) => B): Array<B> => {
  const result: Array<B> = [];
  for (const value of array) {
    result.push(f(value));
  }
  return result;
};
```

# Clip 6. 함수의 타입 다시보기

## 함수의 타입

어떤 **A 타입의 값을 입력** 받아서, 어떤 **B 타입의 값을 반환(return)**하는가?

(input: A) => B
A => B

**문자열을 입력**으로 받아서, **숫자를 반환**하는 함수

(str: string) => number
string => number

## 값이 반환되지 않는 예외 던지기

```typescript
function stringToNumber(str) {
  const result = Number(str);
  if (isNaN(result)) {
    throw new Error('숫자가 아닙니다.');
  }
  return result;
}
```

```
stringToNumber('abc');
> Uncaught Error: 숫자가 아닙니다.
```

## 예외를 표현하는 데이터 타입

type Try<T> = T | Error;

```rescript
Result.t(result, error)
  | Ok(result)
  | Error(error)
```

```haskell
Data Either a b
```

## 예외를 명시적잍 타입으로 반환하기

```typescript
function stringToNumber(str) {
  const result = Number(str);
  if (isNaN(result)) {
    throw new Error('숫자가 아닙니다.');
  }
  return result;
}
```

를 `(str: string) => Try<number>`로 변경

## Array map의 타입 다시보기

제네릭으로 구현한 map

```typescript
type map<A, B> = (Array<A>, A => B) => Array<B>;
```

타입 파라미터 A가 number 타입이라면?

```typescript
(Array<number>, number => B) => Array<B>
```

# Clip 7. map으로 해결하기

```typescript
import './index.css';
import { cart } from './cart';

const stockItem = (item: Item): string => `
  <div class="item">
    <div class="item-name">${item.name}</div>
    <div class="item-price">${item.price}원</div>
    <div class="item-quantity">${item.quantity}상자</div>
  </div>
`;

const outOfStockItem = (item: Item): string => `
  <div class="item gray">
    <div class="item-name strike">${item.name}</div>
    <div class="item-price strike">${item.price}원</div>
    <div class="item-quantity strike">${item.quantity}상자</div>
  </div>
`;

const getItem = (item: Item): string => {
  if (item.quantity > 0) {
    return stockItem(item);
  } else {
    return outOfStockItem(item);
  }
};

const totalCalculator = (
  items: Array<Item>,
  getValue: (item: Item) => number
): number => {
  const total = 0;
  for (let i = 0; i < items.length; i++) {
    if (!items[i].outOfStock) {
      total += getValue(items[i]);
    }
  }
  return total;
};

const getTotalCount = (items: Array<Item>): string => {
  // 전체 목록 중 재고가 있는 상품만 getValue를 실행하고 그 결과를 모두 더한다.

  // 1. 재고가 있는 상품만 분류하기
  // 2. 분류된 상품들에 대해서 getValue 실행하기
  // 3. getValue가 실행된 값 모두 더하기
  return item
    .filter((item) => !item.outOfStock)
    .map(getValue)
    .reduce((total, value) => total + value, 0);
};

const getTotalPrice = (items: Array<Item>): string => {
  const totalPrice = totalCalculator(
    items,
    (item) => item.price * item.quantity
  );
  return `<h2>전체 가격: ${totalPrice}원</h2>`;
};

const list = (items: Array<Item>) => {
  // 1. 목록에 있는 아이템을 태그로 변경
  // 2. 태그의 목록을 모두 하나의 문자열로 연결
  return `
    <ul>
      ${items.map(getItem).reduce((tags, tag) => tags + tag, '')}
    </ul>
  `;
};

const app = document.getElementById('app');
if (app != null) {
  app.innerHTML = `
    <h1>Cart</h1>
    ${list(cart)}
    ${getTotalCount(cart)}
    ${getTotalPrice(cart)}
  `;
}
```

# Clip 8. map의 잘못된 사용

```typescript
import './index.css';
import { cart } from './cart';

const stockItem = (item: Item): string => `
  <div class="item">
    <div class="item-name">${item.name}</div>
    <div class="item-price">${item.price}원</div>
    <div class="item-quantity">${item.quantity}상자</div>
  </div>
`;

const outOfStockItem = (item: Item): string => `
  <div class="item gray">
    <div class="item-name strike">${item.name}</div>
    <div class="item-price strike">${item.price}원</div>
    <div class="item-quantity strike">${item.quantity}상자</div>
  </div>
`;

const getItem = (item: Item): string => {
  if (item.quantity > 0) {
    return stockItem(item);
  } else {
    return outOfStockItem(item);
  }
};

const totalCalculator = (
  items: Array<Item>,
  getValue: (item: Item) => number
): number => {
  const result: Array<number> = [];
  items.forEach(function (item) {
    // map은 잘못된 사용. forEach는 부수효과를 일으키므로 순수하지 않다.
    // 그리고 void를 반환하므로 더이상 함수를 합성할 수 없다.
    if (item.outOfStock === false) {
      result.push(getValue(item));
    }
  });
  return result.reduce((total, value) => total + value, 0);
};

const getTotalCount = (items: Array<Item>): string => {
  // 전체 목록 중 재고가 있는 상품만 getValue를 실행하고 그 결과를 모두 더한다.

  // 1. 재고가 있는 상품만 분류하기
  // 2. 분류된 상품들에 대해서 getValue 실행하기
  // 3. getValue가 실행된 값 모두 더하기
  return item
    .filter((item) => !item.outOfStock)
    .map(getValue)
    .reduce((total, value) => total + value, 0);
};

const getTotalPrice = (items: Array<Item>): string => {
  const totalPrice = totalCalculator(
    items,
    (item) => item.price * item.quantity
  );
  return `<h2>전체 가격: ${totalPrice}원</h2>`;
};

const list = (items: Array<Item>) => {
  // 1. 목록에 있는 아이템을 태그로 변경
  // 2. 태그의 목록을 모두 하나의 문자열로 연결
  return `
    <ul>
      ${items.map(getItem).reduce((tags, tag) => tags + tag, '')}
    </ul>
  `;
};

const app = document.getElementById('app');
if (app != null) {
  app.innerHTML = `
    <h1>Cart</h1>
    ${list(cart)}
    ${getTotalCount(cart)}
    ${getTotalPrice(cart)}
  `;
}
```

# Clip 9. 2중 for문

```typescript
const suits = ['♥', '♠', '♣', '♦'];
const numbers = [
  '2',
  '3',
  '4',
  '5',
  '6',
  '7',
  '8',
  '9',
  '10',
  'J',
  'Q',
  'K',
  'A',
];

const cards: Array<string> = [];

for (const suit of suits) {
  for (const number of numbers) {
    cards.push(suit + number);
  }
}

// 모든 카드 목록은 아래의 작업이 완료된 것이다.
const cards2 =
  // 아래의 작업을 모든 무늬에 적용한다.
  suits.flatMap((suit) =>
    // 아래의 작업을 모든 숫자에 적용한다.
    numbers.map(
      (number) =>
        // 카드는 무늬와 숫자를 연결한 문자열이다.
        suite + number
    )
  );
// 무늬별로 나누어진 카드를 하나로 합친다.
// Array<Array<T>> => Array<T>

const main = () => {
  const app = document.getElementById('app');
  if (app === null) {
    return;
  }

  app.innerHTML = `
    <h1>cards</h1>
    <pre>${JSON.stringify(cards2, null, 2)}</pre>
  `;
};

main();
```
