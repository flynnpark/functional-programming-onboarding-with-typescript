# Clip 1. 돌아보기 > 부수효과와 순수함수

## 핵심 개념 2가지

- 함수를 합성해서 복잡한 프로그램을 쉽게 만들기
- 부수효과를 공통적인 방법으로 추상화

펑터와 모나드와 같은 수학적인 이론이 뒷받침 된다.

## 부수효과 vs 순수 함수

**부수효과(Side effect)**

- 반환값으로 알 수 없는 외부의 상태를 변경하거나 예상치 못한 작용을 하는 것

**순수함수**

- 똑같은 매개변수(입력)을 받으면 항상 같은 값을 반환하는 함수

# Clip 2. 미리보기 > 함수와 함수 합성

## 방향 잡기

- 전역변수에 숨겨진 부수효과 찾아내기
- 절차(Procedure)를 순수함수로 바꾸기
- Record Data와 함수 비교하기
- 함수 합성(Function Composition)
- 함수와 타입, 집합
- 타입을 만드는 함수, 제네릭(Generic)

# Clip 3. 계산과 부수효과의 분리

```typescript
/*
 * 토마토: 7000
 * 오렌지: 15000
 * 사과: 10000함수와 부수효과
 */
export let totalPrice = 0;
totalPrice += 7000;
totalPrice += 15000;
totalPrice += 10000;
totalPrice += 30000; // 10000원 짜리 3개인지, 15000원짜리 2개인지 불분명함
totalPrice += 8000; // 실수할 수도 있음
```

```typescript
// 명령형
/*
 * 토마토: 7000
 * 오렌지: 15000
 * 사과: 10000함수와 부수효과
 */

export let totalPrice = 0;

export function addTomato() {
  // 부수효과를 일으킴
  totalPrice += 7000;
}

export function addOrange() {
  // 부수효과를 일으킴
  totalPrice += 15000;
}

export function addApple() {
  // 부수효과를 일으킴
  totalPrice += 10000;
}

export function list1() {
  // 토마토, 오렌지, 사과 한 상자
  addTomato()
  addOrange()
  addApple()
}

export function list2() {
  // 토마토 2상자
  addTomato()
  addTomato()
}

export function 3() {
  // 오렌지 100상자
  for (let i = 0; i < 100; i++) {
    addOrange()
  }
}
```

# Clip 4. data와 function

```typescript
/*
 * 토마토: 7000
 * 오렌지: 15000
 * 사과: 10000함수와 부수효과
 */

// 과일들의 가격을 반환함
export function priceOfTomato() {
  return 7000;
}

export function priceOfOrange() {
  return 15000;
}

export function priceOfApple() {
  return 10000;
}

export function getPrice(name: string): number {
  if (name === 'tomato') {
    return 7000;
  } else if (name === 'orange') {
    return 15000;
  } else if (name === 'apple') {
    return 10000;
  } else {
    return 0;
  }
}

const priceOfFruit = {
  tomato: 7000,
  orange: 15000,
  apple: 10000,
};

// 입력값이 출력값에 대응된다는 본질은 같음
const isEven = (n: number): boolean => n % 2 === 0;

// 과일들의 가격을 가져오는 함수들을 실행하고, 결과를 반환함
export function list1() {
  return priceOfTomato() + priceOfOrange() + priceOfApple();
}

export function list2() {
  return priceOfTomato() + priceOfTomato();
}

export function list3() {
  return priceOfOrange() * 100;
}

// 부수효과가 없어짐!
```

# Clip 5. 함수와 타입

## 함수의 합성

함수의 합성(Composition)이란 한 함수의 공역이, 다른 함수의 정의역과 일치하는 경우 두 함수를 이어 하나의 함수로 만드는 연산이다.

## 수학에서의 함수: 정의역과 공역

- 수학에서 **함수**는 *어떤 집합의 각 원소*를 *대응 집합의 유일한 원소*에 **대응**시키는 이항 관계다.
- 입력 값들의 집합을 **정의역**이라 한다.
- 이 함숫값들이 속하는 더 큰 집합을 **공역**이라 한다.

## 타입: 할당할 수 있는 값들의 집합

- 수학에서의 **집합**은 특정한 조건에 맞는 별개의 원소들의 모임

```typescript
export function getPrice(name: string) {
  if (name === 'tomato') {
    return 7000;
  } else if (name === 'orange') {
    return 15000;
  } else if (name === 'apple') {
    return 10000;
  }
}
```

## total function 전 함수 vs partial function 부분 함수

- (total) function - (전) 함수
  - 정의역의 **모든** 원소에 대해 함수가 정의되어야 한다.
- partial function - 부분 함수
  - 가능한 입력 중에 **일부**에만 반환값이 정의되어 있다.

# Clip 6. 함수 합성

```typescript
export function getPrice(name: string): number | undefined {
  if (name === 'tomato') {
    return 7000;
  } else if (name === 'orange') {
    return 15000;
  } else if (name === 'apple') {
    return 10000;
  }
}

// 입력 타입을 number | undefined로 변경해서 getPrice의 공역와 isExpensive의 정의역이 일치하도록 함
export const isExpensive = (price: number | undefined) => {
  if (price === undefined) {
    return false;
  }
  return price > 10000;
};

// 함수 합성
// 정의역과 공역이 일치한다면 함수를 계속해서 합성할 수 있음
export function isExpensivePrice(name: string): boolean {
  return isExpensive(getPrice(name));
}

export const main = () => {
  return isExpensive(getPrice('tomato'));
};
```

## 수학의 쓸모

프로그래밍에 엄밀한 수학이 꼭 필요할까?

우리가 만든 추상화에 잘못된 케이스가 있다면?

수학으로 증명할 수 있다면...

- (순수 함수라는) 가정만 잘 지키면 믿을 수 있다.
- 자신있게 합성할 수 있다.
- 이미 잘 증명되어 있는 펑터나 모나드 등을 믿고 슬 수 있다.
